<!-- 
  This module is straight up fork from https://github.com/jewelhuq/PDFJsAnnotations as it was licensed for Commercial use Modification, Distribution, Private use. We thank the developer for commercializing it.
  Please drop a star on the project. We have made some changes to make it work with the general dms api. Please look into redaction.js for more details.

-->

<!DOCTYPE html>
<html>

<head>
  <title></title>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
    integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css" />
</head>

<body>
  <style>
    canvas,
    .canvas-container {
      margin-bottom: 25px;
    }

    .canvas-container {
      margin-left: auto;
      margin-right: auto;
    }

    body {
      background-color: #eee;
    }

    .toolbar {
      display: flex;
      justify-content: space-between;
      background: linear-gradient(to left, #004bc3, #2a7cff, #90bbff);
      align-items: center;
      z-index: 10;
      height: 55px;
    }

    .middle-part {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #pdf-container {
      margin-top: 60px;
      padding-left: 10px;
      text-align: center;
    }

    button:focus {
      outline: 0;
    }

    .toolbar .tool {
      display: inline-block;
      color: #fff;
      height: 100%;
      padding-top: 10px;
      padding-left: 10px;
      margin-right: 5px;
    }

    .toolbar .tool label,
    .toolbar .tool select,
    .toolbar .tool input {
      display: inline-block;
      width: auto;
      height: auto !important;
      padding: 0;
    }

    .toolbar .tool input {
      width: 39px;
      margin-top: 5px;
    }

    .toolbar .tool .color-tool {
      height: 25px;
      width: 25px;
      border-radius: 25px;
      border: 0;
      cursor: pointer;
      display: inline-block;
    }

    .toolbar .tool .color-tool.active {
      border: 1.5px solid #e7e7e7;
      /* add below shadow */
      box-shadow: 0px 10px 5px -2px rgba(0, 0, 0, 0.5);
    }

    .toolbar .tool:nth-last-child(1) {
      float: right;
    }

    .toolbar .tool .tool-button {
      background-color: rgb(50, 54, 57);
      border: 1px solid rgb(50, 54, 57);
      color: #fff;
      cursor: pointer;
    }

    .toolbar .tool .tool-button:hover,
    .toolbar .tool .tool-button.active {
      background-color: rgb(82, 86, 89);
      border-color: rgb(82, 86, 89);
    }

    #loader-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 9999;
      display: none;
    }

    #loader {
      border: 16px solid #f3f3f3;
      border-top: 16px solid #3498db;
      border-radius: 50%;
      width: 120px;
      height: 120px;
      animation: spin 2s linear infinite;
      position: absolute;
      top: 50%;
      left: 50%;
      margin-top: -60px;
      margin-left: -60px;
    }

    .pdf-canvas {
      border-radius: 10px;
      border: 1px solid #000;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }
  </style>

  <div class="main-block">
    <div class="toolbar">
      <div id="loader-overlay">
        <div id="loader"></div>
      </div>
      <div class="tool">
        <span>Redact PDF</span>
      </div>
      <div class="middle-part">
        <div class="tool">
          <label for="">Brush size</label>
          <input type="number" class="form-control text-right" value="1" id="brush-size" max="500" />
        </div>

        <div class="tool">
          <button class="color-tool active" style="background-color: #212121"></button>
          <button class="color-tool" style="background-color: red"></button>
          <button class="color-tool" style="background-color: blue"></button>
        </div>
        <div class="tool">
          <button class="tool-button active">
            <i class="fa fa-hand-paper-o" title="Free Hand" onclick="enableSelector(event)"></i>
          </button>
        </div>
        <div class="tool">
          <button class="tool-button"><i class="fa fa-pencil" title="Pencil" onclick="enablePencil(event)"></i></button>
        </div>
        <!-- <div class="tool">
            <button class="tool-button"><i class="fa fa-font" title="Add Text" onclick="enableAddText(event)"></i></button>
          </div> -->
        <!-- <div class="tool">
            <button class="tool-button">
              <i class="fa fa-long-arrow-right" title="Add Arrow" onclick="enableAddArrow(event)"></i>
            </button>
          </div> -->
        <div class="tool">
          <button class="tool-button">
            <i class="fa fa-square-o" title="Add rectangle" onclick="enableRectangle(event)"></i>
          </button>
        </div>
        <!-- <div class="tool">
            <button class="tool-button">
              <i class="fa fa-picture-o" title="Add an Image" onclick="addImage(event)"></i>
            </button>
          </div> -->
        <div class="tool">
          <button class="btn btn-danger btn-sm" onclick="deleteSelectedObject(event)"><i
              class="fa fa-trash"></i></button>
        </div>
      </div>
      <!-- <div class="tool">
          <button class="btn btn-info btn-sm" onclick="showPdfData()">{}</button>
        </div> -->
      <div class="last-part">
        <div class="tool">
          <button class="btn btn-dark btn-sm" onclick="clearPage()">
            <i class="fa fa-trash-o" aria-hidden="true"></i> Clear Page
          </button>
        </div>
        <div class="tool">
          <button class="btn btn-light btn-sm" id="loader-toggle" onclick="savePDF()">
            <i class="fa fa-save"></i> Save
          </button>
        </div>
      </div>
    </div>

    <div id="pdf-container"></div>
  </div>

  <div class="modal fade" id="dataModal" tabindex="-1" role="dialog" aria-labelledby="dataModalLabel"
    aria-hidden="true">
    <div class="modal-dialog modal-lg" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="dataModalLabel">PDF annotation data</h5>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
          <pre class="prettyprint lang-json linenums"></pre>
        </div>
      </div>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"
    integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
    crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
    integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
    crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.worker.min.js";
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.3.0/fabric.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.2.0/jspdf.umd.min.js"></script>
  <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>

  <script>
    const loaderOverlay = document.getElementById("loader-overlay");

    // Show the loader on page load
    loaderOverlay.style.display = "block";

    // Hide the loader after 5 seconds
    setTimeout(function () {
      loaderOverlay.style.display = "none";
    }, 4000);
    /**
     * From: https://blog.thirdrocktechkno.com/how-to-draw-an-arrow-using-html-5-canvas-and-fabricjs-9500c3f50ecb
     */

    // Extended fabric line class
    //  This new class adds an arrowhead to the end of the line to create a directional arrow.
    // The constructor function initializes the class and calls the parent "Line" class's constructor function to set up its properties.
    // The "toObject" function is called by Fabric.js when serializing an object, and it extends the parent "toObject" function by calling it and returning its result.
    fabric.LineArrow = fabric.util.createClass(fabric.Line, {
      type: "lineArrow",

      initialize: function (element, options) {
        options || (options = {});
        this.callSuper("initialize", element, options);
      },

      toObject: function () {
        return fabric.util.object.extend(this.callSuper("toObject"));
      },

      _render: function (ctx) {
        this.callSuper("_render", ctx);

        // do not render if width/height are zeros or object is not visible
        if (this.width === 0 || this.height === 0 || !this.visible) return;

        ctx.save();

        var xDiff = this.x2 - this.x1;
        var yDiff = this.y2 - this.y1;
        var angle = Math.atan2(yDiff, xDiff);
        ctx.translate((this.x2 - this.x1) / 2, (this.y2 - this.y1) / 2);
        ctx.rotate(angle);
        ctx.beginPath();
        //move 10px in front of line to start the arrow so it does not have the square line end showing in front (0,0)
        ctx.moveTo(10, 0);
        ctx.lineTo(-20, 15);
        ctx.lineTo(-20, -15);
        ctx.closePath();
        ctx.fillStyle = this.stroke;
        ctx.fill();

        ctx.restore();
      },
    });

    fabric.LineArrow.fromObject = function (object, callback) {
      callback && callback(new fabric.LineArrow([object.x1, object.y1, object.x2, object.y2], object));
    };

    fabric.LineArrow.async = true;

    // The constructor function takes three parameters: the canvas to draw on, the color of the arrow, and a callback function to be executed after the arrow has been drawn.

    var Arrow = (function () {
      function Arrow(canvas, color, callback) {
        this.canvas = canvas;
        this.className = "Arrow";
        this.isDrawing = false;
        this.color = color;
        this.callback = callback;
        // The "bindEvents" function sets up event listeners on the canvas for mouse events like "mouse:down", "mouse:move", and "mouse:up". It also sets up an event listener for the "object:moving" event to prevent the arrow from being drawn while another object on the canvas is being moved.
        this.bindEvents();
      }

      Arrow.prototype.bindEvents = function () {
        var inst = this;
        inst.canvas.on("mouse:down", function (o) {
          inst.onMouseDown(o);
        });
        inst.canvas.on("mouse:move", function (o) {
          inst.onMouseMove(o);
        });
        inst.canvas.on("mouse:up", function (o) {
          inst.onMouseUp(o);
        });
        inst.canvas.on("object:moving", function (o) {
          inst.disable();
        });
      };
      // The "unBindEventes" function removes the event listeners that were set up in the "bindEvents" function.
      Arrow.prototype.unBindEventes = function () {
        var inst = this;
        inst.canvas.off("mouse:down");
        inst.canvas.off("mouse:up");
        inst.canvas.off("mouse:move");
        inst.canvas.off("object:moving");
      };

      // The "onMouseUp" function is called when the mouse button is released after drawing the arrow. It disables drawing mode and removes the event listeners.

      Arrow.prototype.onMouseUp = function (o) {
        var inst = this;
        inst.disable();
        inst.unBindEventes();
        if (inst.callback) inst.callback();
      };

      // The "onMouseMove" function is called when the mouse is moved after drawing has begun. If the drawing mode is enabled, it updates the position of the arrow based on the current mouse pointer position.
      Arrow.prototype.onMouseMove = function (o) {
        var inst = this;
        if (!inst.isEnable()) {
          return;
        }

        var pointer = inst.canvas.getPointer(o.e);
        var activeObj = inst.canvas.getActiveObject();
        activeObj.set({
          x2: pointer.x,
          y2: pointer.y,
        });
        activeObj.setCoords();
        inst.canvas.renderAll();
      };
      // The "onMouseDown" function is called when the mouse button is pressed to begin drawing the arrow. It enables the drawing mode, gets the current mouse pointer position, creates a new "LineArrow" object (a custom Fabric.js class that extends the "Line" class to add an arrowhead to the end of the line), and adds it to the canvas.
      Arrow.prototype.onMouseDown = function (o) {
        var inst = this;
        inst.enable();
        var pointer = inst.canvas.getPointer(o.e);

        var points = [pointer.x, pointer.y, pointer.x, pointer.y];
        var line = new fabric.LineArrow(points, {
          strokeWidth: 5,
          fill: inst.color ? inst.color : "red",
          stroke: inst.color ? inst.color : "red",
          originX: "center",
          originY: "center",
          hasBorders: false,
          hasControls: true,
          selectable: true,
        });

        inst.canvas.add(line).setActiveObject(line);
      };

      Arrow.prototype.isEnable = function () {
        return this.isDrawing;
      };

      // The "isEnable", "enable", and "disable" functions are used to check, enable, and disable the drawing mode, respectively.

      Arrow.prototype.enable = function () {
        this.isDrawing = true;
      };

      Arrow.prototype.disable = function () {
        this.isDrawing = false;
      };

      return Arrow;
    })();

    // The constructor takes three arguments: container_id is the ID of the DOM element where the PDF will be rendered; url is the URL of the PDF document to be rendered; and options is an object that can contain various optional parameters, such as scale, pageImageCompression, onPageUpdated, and ready.
    var PDFAnnotate = function (container_id, url, options = {}) {
      this.number_of_pages = 0;
      this.pages_rendered = 0;
      this.active_tool = 1; // 1 - Free hand, 2 - Text, 3 - Arrow, 4 - Rectangle
      this.fabricObjects = [];
      this.fabricObjectsData = [];
      this.color = "#212121";
      this.borderColor = "#000000";
      this.borderSize = 1;
      this.font_size = 16;
      this.active_canvas = 0;
      this.container_id = container_id;
      this.url = url;
      this.pageImageCompression = options.pageImageCompression ? options.pageImageCompression.toUpperCase() : "NONE";
      this.textBoxText = "Sample Text";
      this.format;
      this.orientation;
      var inst = this;

      // Inside the constructor, the PDF document is loaded using pdfjsLib.getDocument() from the pdf.js library. The number of pages in the PDF is determined, and for each page, a canvas element is created and the page is rendered onto it using pdf.getPage() and page.render(). The canvas elements are then initialized with Fabric.js, a library for working with HTML5 canvas, and added to the DOM.
      var loadingTask = pdfjsLib.getDocument(this.url);
      loadingTask.promise.then(
        function (pdf) {
          var scale = options.scale ? options.scale : 1.3;
          inst.number_of_pages = pdf.numPages;

          for (var i = 1; i <= pdf.numPages; i++) {
            pdf.getPage(i).then(function (page) {
              if (typeof inst.format === "undefined" || typeof inst.orientation === "undefined") {
                var originalViewport = page.getViewport({ scale: 1 });
                inst.format = [originalViewport.width, originalViewport.height];
                inst.orientation = originalViewport.width > originalViewport.height ? "landscape" : "portrait";
              }

              var viewport = page.getViewport({ scale: scale });
              var canvas = document.createElement("canvas");
              document.getElementById(inst.container_id).appendChild(canvas);
              canvas.className = "pdf-canvas";
              canvas.height = viewport.height;
              canvas.width = viewport.width;
              context = canvas.getContext("2d");

              var renderContext = {
                canvasContext: context,
                viewport: viewport,
              };
              var renderTask = page.render(renderContext);
              renderTask.promise.then(function () {
                $(".pdf-canvas").each(function (index, el) {
                  $(el).attr("id", "page-" + (index + 1) + "-canvas");
                });
                inst.pages_rendered++;
                if (inst.pages_rendered == inst.number_of_pages) inst.initFabric();
              });
            });
          }
        },
        function (reason) {
          console.error(reason);
        }
      );

      // The initFabric() method initializes Fabric.js for each canvas element, sets the background image to the rendered PDF page, and adds event listeners for clicks on the canvas. The fabricClickHandler() method handles clicks on the canvas and adds the appropriate annotation to the Fabric.js canvas object.
      this.initFabric = function () {
        var inst = this;
        let canvases = $("#" + inst.container_id + " canvas");
        canvases.each(function (index, el) {
          var background = el.toDataURL("image/png");
          var fabricObj = new fabric.Canvas(el.id, {
            freeDrawingBrush: {
              width: 1,
              color: inst.color,
            },
          });
          inst.fabricObjects.push(fabricObj);
          if (typeof options.onPageUpdated == "function") {
            fabricObj.on("object:added", function () {
              var oldValue = Object.assign({}, inst.fabricObjectsData[index]);
              inst.fabricObjectsData[index] = fabricObj.toJSON();
              options.onPageUpdated(index + 1, oldValue, inst.fabricObjectsData[index]);
            });
          }
          fabricObj.setBackgroundImage(background, fabricObj.renderAll.bind(fabricObj));
          $(fabricObj.upperCanvasEl).click(function (event) {
            inst.active_canvas = index;
            inst.fabricClickHandler(event, fabricObj);
          });
          fabricObj.on("after:render", function () {
            inst.fabricObjectsData[index] = fabricObj.toJSON();
            fabricObj.off("after:render");
          });

          if (index === canvases.length - 1 && typeof options.ready === "function") {
            options.ready();
          }
        });
      };

      this.fabricClickHandler = function (event, fabricObj) {
        var inst = this;
        var toolObj;
        if (inst.active_tool == 2) {
          toolObj = new fabric.IText(inst.textBoxText, {
            left: event.clientX - fabricObj.upperCanvasEl.getBoundingClientRect().left,
            top: event.clientY - fabricObj.upperCanvasEl.getBoundingClientRect().top,
            fill: inst.color,
            fontSize: inst.font_size,
            selectable: true,
          });
        } else if (inst.active_tool == 4) {
          toolObj = new fabric.Rect({
            left: event.clientX - fabricObj.upperCanvasEl.getBoundingClientRect().left,
            top: event.clientY - fabricObj.upperCanvasEl.getBoundingClientRect().top,
            width: 100,
            height: 100,
            fill: inst.color,
            stroke: inst.borderColor,
            strokeSize: inst.borderSize,
          });
        }

        if (toolObj) {
          fabricObj.add(toolObj);
        }
      };
    };

    PDFAnnotate.prototype.enableSelector = function () {
      var inst = this;
      inst.active_tool = 0;
      if (inst.fabricObjects.length > 0) {
        $.each(inst.fabricObjects, function (index, fabricObj) {
          fabricObj.isDrawingMode = false;
        });
      }
    };

    PDFAnnotate.prototype.enablePencil = function () {
      var inst = this;
      inst.active_tool = 1;
      if (inst.fabricObjects.length > 0) {
        $.each(inst.fabricObjects, function (index, fabricObj) {
          fabricObj.isDrawingMode = true;
        });
      }
    };

    PDFAnnotate.prototype.enableAddText = function (text) {
      var inst = this;
      inst.active_tool = 2;
      if (typeof text === "string") {
        inst.textBoxText = text;
      }
      if (inst.fabricObjects.length > 0) {
        $.each(inst.fabricObjects, function (index, fabricObj) {
          fabricObj.isDrawingMode = false;
        });
      }
    };

    PDFAnnotate.prototype.enableRectangle = function () {
      var inst = this;
      var fabricObj = inst.fabricObjects[inst.active_canvas];
      inst.active_tool = 4;
      if (inst.fabricObjects.length > 0) {
        $.each(inst.fabricObjects, function (index, fabricObj) {
          fabricObj.isDrawingMode = false;
        });
      }
    };

    PDFAnnotate.prototype.enableAddArrow = function (onDrawnCallback = null) {
      var inst = this;
      inst.active_tool = 3;
      if (inst.fabricObjects.length > 0) {
        $.each(inst.fabricObjects, function (index, fabricObj) {
          fabricObj.isDrawingMode = false;
          new Arrow(fabricObj, inst.color, function () {
            inst.active_tool = 0;
            if (typeof onDrawnCallback === "function") {
              onDrawnCallback();
            }
          });
        });
      }
    };

    PDFAnnotate.prototype.addImageToCanvas = function () {
      var inst = this;
      var fabricObj = inst.fabricObjects[inst.active_canvas];

      if (fabricObj) {
        var inputElement = document.createElement("input");
        inputElement.type = "file";
        inputElement.accept = ".jpg,.jpeg,.png,.PNG,.JPG,.JPEG";
        inputElement.onchange = function () {
          var reader = new FileReader();
          reader.addEventListener(
            "load",
            function () {
              inputElement.remove();
              var image = new Image();
              image.onload = function () {
                fabricObj.add(new fabric.Image(image));
              };
              image.src = this.result;
            },
            false
          );
          reader.readAsDataURL(inputElement.files[0]);
        };
        document.getElementsByTagName("body")[0].appendChild(inputElement);
        inputElement.click();
      }
    };

    PDFAnnotate.prototype.deleteSelectedObject = function () {
      var inst = this;
      var activeObject = inst.fabricObjects[inst.active_canvas].getActiveObject();
      if (activeObject) {
        if (confirm("Are you sure ?")) {
          inst.fabricObjects[inst.active_canvas].remove(activeObject);
        }
      }
    };

    PDFAnnotate.prototype.savePdf = function (fileName) {
      var inst = this;
      var format = inst.format || "a4";
      var orientation = inst.orientation || "portrait";
      if (!inst.fabricObjects.length) return;
      var doc = new jspdf.jsPDF({ format, orientation });
      if (typeof fileName === "undefined") {
        fileName = `${new Date().getTime()}.pdf`;
      }

      inst.fabricObjects.forEach(function (fabricObj, index) {
        if (index != 0) {
          doc.addPage(format, orientation);
          doc.setPage(index + 1);
        }
        doc.addImage(
          fabricObj.toDataURL({
            format: "png",
          }),
          inst.pageImageCompression == "NONE" ? "PNG" : "JPEG",
          0,
          0,
          doc.internal.pageSize.getWidth(),
          doc.internal.pageSize.getHeight(),
          `page-${index + 1}`,
          ["FAST", "MEDIUM", "SLOW"].indexOf(inst.pageImageCompression) >= 0 ? inst.pageImageCompression : undefined
        );
        if (index === inst.fabricObjects.length - 1) {
          doc.save(fileName);
          const newPdf = new File([doc.output("blob")], fileName, { type: "pdf" });
          let formData = new FormData();
          formData.append("pdfFile", newPdf);

          fetch("http://localhost:8181/api/redactedFile", {
            method: "POST",
            body: formData,
          })
            .then((response) => response.json())
            .then((data) => {
              console.log(data);
            })
            .catch((error) => {
              console.error(error);
            });
        }
      });
    };
    PDFAnnotate.prototype.setBrushSize = function (size) {
      var inst = this;
      $.each(inst.fabricObjects, function (index, fabricObj) {
        fabricObj.freeDrawingBrush.width = parseInt(size, 10) || 1;
      });
    };

    PDFAnnotate.prototype.setColor = function (color) {
      var inst = this;
      inst.color = color;
      $.each(inst.fabricObjects, function (index, fabricObj) {
        fabricObj.freeDrawingBrush.color = color;
      });
    };

    PDFAnnotate.prototype.setBorderColor = function (color) {
      var inst = this;
      inst.borderColor = color;
    };

    PDFAnnotate.prototype.setFontSize = function (size) {
      this.font_size = size;
    };

    PDFAnnotate.prototype.setBorderSize = function (size) {
      this.borderSize = size;
    };

    PDFAnnotate.prototype.clearActivePage = function () {
      var inst = this;
      var fabricObj = inst.fabricObjects[inst.active_canvas];
      var bg = fabricObj.backgroundImage;
      if (confirm("Are you sure?")) {
        fabricObj.clear();
        fabricObj.setBackgroundImage(bg, fabricObj.renderAll.bind(fabricObj));
      }
    };

    PDFAnnotate.prototype.serializePdf = function (callback) {
      var inst = this;
      var pageAnnotations = [];
      inst.fabricObjects.forEach(function (fabricObject) {
        fabricObject.clone(function (fabricObjectCopy) {
          fabricObjectCopy.setBackgroundImage(null);
          fabricObjectCopy.setBackgroundColor("");
          pageAnnotations.push(fabricObjectCopy);
          if (pageAnnotations.length === inst.fabricObjects.length) {
            var data = {
              page_setup: {
                format: inst.format,
                orientation: inst.orientation,
              },
              pages: pageAnnotations,
            };
            callback(JSON.stringify(data));
          }
        });
      });
    };

    PDFAnnotate.prototype.loadFromJSON = function (jsonData) {
      var inst = this;
      var { page_setup, pages } = jsonData;
      if (typeof pages === "undefined") {
        pages = jsonData;
      }
      if (
        typeof page_setup === "object" &&
        typeof page_setup.format === "string" &&
        typeof page_setup.orientation === "string"
      ) {
        inst.format = page_setup.format;
        inst.orientation = page_setup.orientation;
      }
      $.each(inst.fabricObjects, function (index, fabricObj) {
        if (pages.length > index) {
          fabricObj.loadFromJSON(pages[index], function () {
            inst.fabricObjectsData[index] = fabricObj.toJSON();
          });
        }
      });
    };

    PDFAnnotate.prototype.setDefaultTextForTextBox = function (text) {
      var inst = this;
      if (typeof text === "string") {
        inst.textBoxText = text;
      }
    };

    // make api call to http://192.168.1.112:8181/api/redactionId and get the id

    let xhr = new XMLHttpRequest();
    let pdf;
    xhr.open("GET", "http://localhost:8181/api/redactionId");
    xhr.onload = function () {
      if (xhr.status === 200) {
        let responseString = xhr.responseText;
        var newpdf = new PDFAnnotate("pdf-container", responseString, {
          onPageUpdated(page, oldData, newData) {
            console.log(page, oldData, newData);
          },
          ready() {
            console.log("Plugin initialized successfully");
            // pdf.loadFromJSON(sampleOutput);
          },
          scale: 1.5,
          pageImageCompression: "MEDIUM", // FAST, MEDIUM, SLOW(Helps to control the new PDF file size)
        });
        pdf = newpdf;
      } else {
        console.error("Error:", xhr.statusText);
      }
    };
    xhr.send();

    function changeActiveTool(event) {
      var element = $(event.target).hasClass("tool-button")
        ? $(event.target)
        : $(event.target).parents(".tool-button").first();
      $(".tool-button.active").removeClass("active");
      $(element).addClass("active");
    }

    function enableSelector(event) {
      event.preventDefault();
      changeActiveTool(event);
      pdf.enableSelector();
    }

    function enablePencil(event) {
      event.preventDefault();
      changeActiveTool(event);
      pdf.enablePencil();
    }

    function enableAddText(event) {
      event.preventDefault();
      changeActiveTool(event);
      pdf.enableAddText();
    }

    function enableAddArrow(event) {
      event.preventDefault();
      changeActiveTool(event);
      pdf.enableAddArrow(function () {
        $(".tool-button").first().find("i").click();
      });
    }

    function addImage(event) {
      event.preventDefault();
      pdf.addImageToCanvas();
    }

    function enableRectangle(event) {
      event.preventDefault();
      changeActiveTool(event);
      pdf.setColor("rgba(0, 0, 0, 1)");
      pdf.setBorderColor("black");
      pdf.enableRectangle();
    }

    function deleteSelectedObject(event) {
      event.preventDefault();
      pdf.deleteSelectedObject();
    }

    function savePDF() {
      const loaderOverlay = document.getElementById("loader-overlay");

      loaderOverlay.style.display = "block";

      // Hide the loader after 5 seconds
      setTimeout(function () {
        loaderOverlay.style.display = "none";
      }, 5000);
      let xhr = new XMLHttpRequest();
      xhr.open("GET", "http://localhost:8181/api/redactionId");
      xhr.onload = function () {
        if (xhr.status === 200) {
          const responseString = xhr.responseText;
          const pathParts = responseString.split("/");
          const pdfName = pathParts[pathParts.length - 1];
          const pdfNameWithoutPrefix = pdfName.substring(pdfName.indexOf("-") + 1, pdfName.lastIndexOf("."));
          if (pdfNameWithoutPrefix) {
            return pdf.savePdf(`${pdfNameWithoutPrefix}.pdf`);
          } // save with given file name
        } else {
          console.error("Error:", xhr.statusText);
        }
      };
      xhr.send();
    }

    function clearPage() {
      pdf.clearActivePage();
    }

    function showPdfData() {
      pdf.serializePdf(function (string) {
        $("#dataModal .modal-body pre")
          .first()
          .text(JSON.stringify(JSON.parse(string), null, 4));
        PR.prettyPrint();
        $("#dataModal").modal("show");
      });
    }

    $(function () {
      $(".color-tool").click(function () {
        $(".color-tool.active").removeClass("active");
        $(this).addClass("active");
        color = $(this).get(0).style.backgroundColor;
        pdf.setColor(color);
      });

      $("#brush-size").change(function () {
        var width = $(this).val();
        pdf.setBrushSize(width);
      });

      $("#font-size").change(function () {
        var font_size = $(this).val();
        pdf.setFontSize(font_size);
      });
    });
  </script>
</body>

</html>